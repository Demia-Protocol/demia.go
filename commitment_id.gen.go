package iotago

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"

	"sync"

	"golang.org/x/crypto/blake2b"

	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/iota.go/v4/hexutil"
)

const (
	CommitmentIDLength = IdentifierLength + SlotIndexLength
)

var (
	ErrInvalidCommitmentIDLength = ierrors.New("invalid commitmentID length")

	EmptyCommitmentID = CommitmentID{}
)

// CommitmentID is a 32 byte hash value together with an 4 byte slot index.
type CommitmentID [CommitmentIDLength]byte

// CommitmentIDRepresentingData returns a new CommitmentID for the given data by hashing it with blake2b and associating it with the given slot index.
func CommitmentIDRepresentingData(slot SlotIndex, data []byte) CommitmentID {
	return NewCommitmentID(slot, blake2b.Sum256(data))
}

func NewCommitmentID(slot SlotIndex, idBytes Identifier) CommitmentID {
	c := CommitmentID{}
	copy(c[:], idBytes[:])
	binary.LittleEndian.PutUint32(c[IdentifierLength:], uint32(slot))

	return c
}

// CommitmentIDFromHexString converts the hex to a CommitmentID representation.
func CommitmentIDFromHexString(hex string) (CommitmentID, error) {
	b, err := hexutil.DecodeHex(hex)
	if err != nil {
		return CommitmentID{}, err
	}

	s, _, err := CommitmentIDFromBytes(b)

	return s, err
}

// CommitmentIDFromBytes returns a new CommitmentID represented by the passed bytes.
func CommitmentIDFromBytes(b []byte) (CommitmentID, int, error) {
	if len(b) < CommitmentIDLength {
		return CommitmentID{}, 0, ErrInvalidCommitmentIDLength
	}

	return CommitmentID(b), CommitmentIDLength, nil
}

// MustCommitmentIDFromHexString converts the hex to a CommitmentID representation.
func MustCommitmentIDFromHexString(hex string) CommitmentID {
	c, err := CommitmentIDFromHexString(hex)
	if err != nil {
		panic(err)
	}

	return c
}

func (c CommitmentID) Bytes() ([]byte, error) {
	return c[:], nil
}

func (c CommitmentID) MarshalText() (text []byte, err error) {
	dst := make([]byte, hex.EncodedLen(len(CommitmentID{})))
	hex.Encode(dst, c[:])

	return dst, nil
}

func (c *CommitmentID) UnmarshalText(text []byte) error {
	_, err := hex.Decode(c[:], text)

	return err
}

// Empty tells whether the CommitmentID is empty.
func (c CommitmentID) Empty() bool {
	return c == EmptyCommitmentID
}

// ToHex converts the Identifier to its hex representation.
func (c CommitmentID) ToHex() string {
	return hexutil.EncodeHex(c[:])
}

func (c CommitmentID) String() string {
	return fmt.Sprintf("CommitmentID(%s:%d)", c.Alias(), c.Slot())
}

func (c CommitmentID) Slot() SlotIndex {
	return SlotIndex(binary.LittleEndian.Uint32(c[IdentifierLength:]))
}

// Index returns a slot index to conform with hive's IndexedID interface.
func (c CommitmentID) Index() SlotIndex {
	return c.Slot()
}

func (c CommitmentID) Identifier() Identifier {
	return Identifier(c[:IdentifierLength])
}

var (
	// CommitmentIDAliases contains a dictionary of identifiers associated to their human-readable alias.
	CommitmentIDAliases = make(map[CommitmentID]string)

	// commitmentIDAliasesMutex is the mutex that is used to synchronize access to the previous map.
	commitmentIDAliasesMutex = sync.RWMutex{}
)

// RegisterAlias allows to register a human-readable alias for the Identifier which will be used as a replacement for
// the String method.
func (c CommitmentID) RegisterAlias(alias string) {
	commitmentIDAliasesMutex.Lock()
	defer commitmentIDAliasesMutex.Unlock()

	CommitmentIDAliases[c] = alias
}

// Alias returns the human-readable alias of the Identifier (or the base58 encoded bytes of no alias was set).
func (c CommitmentID) Alias() (alias string) {
	commitmentIDAliasesMutex.RLock()
	defer commitmentIDAliasesMutex.RUnlock()

	if existingAlias, exists := CommitmentIDAliases[c]; exists {
		return existingAlias
	}

	return c.ToHex()
}

// UnregisterAlias allows to unregister a previously registered alias.
func (c CommitmentID) UnregisterAlias() {
	commitmentIDAliasesMutex.Lock()
	defer commitmentIDAliasesMutex.Unlock()

	delete(CommitmentIDAliases, c)
}
