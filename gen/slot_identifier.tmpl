package iotago

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
{{if index .Features "ids"}} "bytes" {{end}}
	"encoding/binary"
	"encoding/hex"
	"fmt"
	{{if index .Features "ids"}} "sort" {{end}}
	"sync"

	"golang.org/x/crypto/blake2b"

	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/iota.go/v4/hexutil"
)

const (
	{{.Name}}Length = IdentifierLength + SlotIndexLength
)

var (
    ErrInvalid{{.Name}}Length = ierrors.New("invalid {{firstLower .Name}} length")

	Empty{{.Name}} = {{.Name}}{}
)

// {{.Name}} is a 32 byte hash value together with an 4 byte slot index.
type {{.Name}} [{{.Name}}Length]byte

// {{.Name}}RepresentingData returns a new {{.Name}} for the given data by hashing it with blake2b and associating it with the given slot index.
func {{.Name}}RepresentingData(slot SlotIndex, data []byte) {{.Name}} {
	return New{{.Name}}(slot, blake2b.Sum256(data))
}

func New{{.Name}}(slot SlotIndex, idBytes Identifier) {{.Name}} {
	{{.Receiver}} := {{.Name}}{}
	copy({{.Receiver}}[:], idBytes[:])
	binary.LittleEndian.PutUint32({{.Receiver}}[IdentifierLength:], uint32(slot))

	return {{.Receiver}}
}

// {{.Name}}FromHexString converts the hex to a {{.Name}} representation.
func {{.Name}}FromHexString(hex string) ({{.Name}}, error) {
	b, err := hexutil.DecodeHex(hex)
	if err != nil {
		return {{.Name}}{}, err
	}

	s, _, err := {{.Name}}FromBytes(b)

	return s, err
}

// {{.Name}}FromBytes returns a new {{.Name}} represented by the passed bytes.
func {{.Name}}FromBytes(b []byte) ({{.Name}}, int, error) {
	if len(b) < {{.Name}}Length {
		return {{.Name}}{}, 0, ErrInvalid{{.Name}}Length
	}

	return {{.Name}}(b), {{.Name}}Length, nil
}

// Must{{.Name}}FromHexString converts the hex to a {{.Name}} representation.
func Must{{.Name}}FromHexString(hex string) {{.Name}} {
	{{.Receiver}}, err := {{.Name}}FromHexString(hex)
	if err != nil {
		panic(err)
	}

	return {{.Receiver}}
}

func ({{.Receiver}} {{.Name}}) Bytes() ([]byte, error) {
	return {{.Receiver}}[:], nil
}

func ({{.Receiver}} {{.Name}}) MarshalText() (text []byte, err error) {
	dst := make([]byte, hex.EncodedLen(len({{.Name}}{})))
	hex.Encode(dst, {{.Receiver}}[:])

	return dst, nil
}

func ({{.Receiver}} *{{.Name}}) UnmarshalText(text []byte) error {
	_, err := hex.Decode({{.Receiver}}[:], text)

	return err
}

// Empty tells whether the {{.Name}} is empty.
func ({{.Receiver}} {{.Name}}) Empty() bool {
	return {{.Receiver}} == Empty{{.Name}}
}

// ToHex converts the Identifier to its hex representation.
func ({{.Receiver}} {{.Name}}) ToHex() string {
	return hexutil.EncodeHex({{.Receiver}}[:])
}

func ({{.Receiver}} {{.Name}}) String() string {
	return fmt.Sprintf("{{.Name}}(%s:%d)", {{.Receiver}}.Alias(), {{.Receiver}}.Slot())
}

func ({{.Receiver}} {{.Name}}) Slot() SlotIndex {
	return SlotIndex(binary.LittleEndian.Uint32({{.Receiver}}[IdentifierLength:]))
}

// Index returns a slot index to conform with hive's IndexedID interface.
func ({{.Receiver}} {{.Name}}) Index() SlotIndex {
	return {{.Receiver}}.Slot()
}

func ({{.Receiver}} {{.Name}}) Identifier() Identifier {
	return Identifier({{.Receiver}}[:IdentifierLength])
}

var (
	// {{.Name}}Aliases contains a dictionary of identifiers associated to their human-readable alias.
	{{.Name}}Aliases = make(map[{{.Name}}]string)

	// {{.Name}}AliasesMutex is the mutex that is used to synchronize access to the previous map.
	{{.Name}}AliasesMutex = sync.RWMutex{}
)

// RegisterAlias allows to register a human-readable alias for the Identifier which will be used as a replacement for
// the String method.
func ({{.Receiver}} {{.Name}}) RegisterAlias(alias string) {
	{{.Name}}AliasesMutex.Lock()
	defer {{.Name}}AliasesMutex.Unlock()

	{{.Name}}Aliases[{{.Receiver}}] = alias
}

// Alias returns the human-readable alias of the Identifier (or the base58 encoded bytes of no alias was set).
func ({{.Receiver}} {{.Name}}) Alias() (alias string) {
	{{.Name}}AliasesMutex.RLock()
	defer {{.Name}}AliasesMutex.RUnlock()

	if existingAlias, exists := {{.Name}}Aliases[{{.Receiver}}]; exists {
		return existingAlias
	}

	return {{.Receiver}}.ToHex()
}

// UnregisterAlias allows to unregister a previously registered alias.
func ({{.Receiver}} {{.Name}}) UnregisterAlias() {
	{{.Name}}AliasesMutex.Lock()
	defer {{.Name}}AliasesMutex.Unlock()

	delete({{.Name}}Aliases, {{.Receiver}})
}


{{if index .Features "ids"}}

type {{.Name}}s []{{.Name}}

// ToHex converts the {{.Name}}s to their hex representation.
func (ids {{.Name}}s) ToHex() []string {
	hexIDs := make([]string, len(ids))
	for i, {{.Receiver}} := range ids {
		hexIDs[i] = hexutil.EncodeHex({{.Receiver}}[:])
	}

	return hexIDs
}

// RemoveDupsAndSort removes duplicated {{.Name}}s and sorts the slice by the lexical ordering.
func (ids {{.Name}}s) RemoveDupsAndSort() {{.Name}}s {
	sorted := append({{.Name}}s{}, ids...)
	sort.Slice(sorted, func(i, j int) bool {
		return bytes.Compare(sorted[i][:], sorted[j][:]) == -1
	})

	var result {{.Name}}s
	var prev {{.Name}}
	for i, {{.Receiver}} := range sorted {
		if i == 0 || !bytes.Equal(prev[:], {{.Receiver}}[:]) {
			result = append(result, {{.Receiver}})
		}
		prev = {{.Receiver}}
	}

	return result
}

// {{.Name}}sFromHexString converts the given block IDs from their hex to {{.Name}} representation.
func {{.Name}}sFromHexString({{.Name}}sHex []string) ({{.Name}}s, error) {
	result := make({{.Name}}s, len({{.Name}}sHex))

	for i, hexString := range {{.Name}}sHex {
		{{.Name}}, err := {{.Name}}FromHexString(hexString)
		if err != nil {
			return nil, err
		}
		result[i] = {{.Name}}
	}

	return result, nil
}
{{end}}
